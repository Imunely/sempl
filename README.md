## PHP 8.1.4 (cli). Дополнительные библиотеки не трубеются.

Интерфейс **Bandit.php** реализует классы для **UCB-1, UCBTuned и Wilson**.

## Описание и Область допустимых значений параметров функций

### UCB1

- **Это детерминированный алгоритм** — то есть при одинаковых входных данных он будет возвращать одинаковый результат. Важно иметь ввиду, что результат алгоритма **дает высокий шанс "молодым записям"**, поэтому старому контенту придется иметь очень хороший рейтинг чтобы осаваться в топе!
- Функция $$weight=s/n+C*√[ln(N)/n]$$ где
  - s - клики для данной записи,
  - n - просмотры для данной записи: `(n > 0)`,
  - С - коэфицент оптимистичности: `C ∈ (0, 1)` Чем выше, тем больше вероятность новому залететь в том `(рекомендуется С = 0.3)`,
  - N - Общее количество просмотров по всем записям: `(N ≥ 2)`,
- Конструктор класса `Ucb1()` по умолчанию записи с 0 просмотров выставляет в 1 (параметр `$start_count_views`)
  ```php
  __construct(
          array $samples,
          $koef = 0.3,
          int $start_count_views = 1
  )
  /**
   * $samples = [ 'заголовок' => ['кол-во просмотров', 'кол-во кликов'] ]
  **/
  ```

### UCB-Tuned

- Модернизированный алгоритм UCB1 c учетом дисперсии наблюдений. На практике показывает лучшие результаты в отличии от UCB1 изза учета дисперсии, но тем не менее также нацелен на новый контент.
- Функция $$weight=s/n+C*√[(logN / n) * min(1/4, V(n))]$$ где
  - $$V(n) = Σ(x_i² / n) - (Σ (x_i / n))² + √(2*log(N) / n)$$
  - s - клики для данной записи,
  - n - просмотры для данной записи: `(n > 0)`,
  - С - коэфицент оптимистичности: `C ∈ (0, 1)` Чем выше, тем больше вероятность новому залететь в том `(рекомендуется С = [0,1;0,5])`,
  - N - Общее количество просмотров по всем записям: `(N ≥ 2)`,
- Конструктор класса `UcbTuned()` по умолчанию записи с 0 просмотров выставляет в 1 (параметр `$start_count_views`)

  ```php
  __construct(
          array $samples,
          $koef = 0.3,
          int $start_count_views = 1
  )
  /**
   * $samples = [ 'заголовок' => ['кол-во просмотров', 'кол-во кликов'] ]
  **/
  ```

### Wilson

- Как и UCB1, является детерминированным алгоритмом. Вес полностью рассчитывается на лету, так как завязан только на статистику конкретного контента.
- Функция
  - $$weight = (s/n+z^2/2n±z/2√[s/n(1-s/n)+z^2/4n])/(1+z^2/n)$$
    где
  - s - клики для данной записи,
  - n - просмотры для данной записи: `(n > 0)`,
  - Z - константа, определяющая величину доверительного интервала. Cтатистически доверительный уровень: установите его в 0.95, чтобы с 95% вероятностью рассчитывать на достоверность, в 0.975, чтобы иметь 97.5% вероятности. Число Z в этой функции никогда не меняется. (Используйте 1.0 = 85%, 1.6 = 95%). В задаче многорукого бандита используется верхняя граница доверительного интервала.
- Конструктор класса `Wilson()` по умолчанию записи с 0 просмотров выставляет в 1 (параметр `$start_count_views`)

  ```php
  __construct(
          array $samples,
          float $z = 1.6, // = 95%
          int $start_count_views = 1
  )
  /**
   * $samples = [ 'заголовок' => ['кол-во просмотров', 'кол-во кликов'] ]
  **/
  ```

### Важно:
#### Количество успехов не может превышать количество всевозможных попыток. 
=======
Интерфейс **Bandit.php** реализует классы для **UCB-1, UCBTuned, Wilson**. 


На входе массив статистических данных ввиде:

```php
[ 'заголовок' => ['кол-во просмотров', 'кол-во кликов'] ]
```
### Важно: 
#### 1. количество успехов не может превышать количество всевозможных попыток. |Т.e кол-во кликов не может быть выше кол-ва просмотров|;
#### 2. Общее количество событий для всех документов должно превышать 1;
#### 3. Записи, имеющие 0 просмотров выставляются в 1 просмотр

**Например:** Запись **"Hello world"** имеет 10 просмотров и 0 клика. 

Тогда собирается массив:

```php
[
"Hello world"=>[10, 0]
]
```

**Код:**

```php

Ucb1 __construct(
        array $samples,
        $koef = 0.3,
        int $start_count_views = 1
)

$th = new Ucb1(['a1'=>[10, 0],'a2'=>[32, 4], 'a3'=>[321, 80]], 0.4, 2);

$th->predict(true);

// return
//      Array
//      (
//          [a3] => r1
//          [a1] => r2
//          [a2] => r3
//      )
```

Метод `predict(): array` выполняет расчет приоритетов каждой записи и возвращает результирующий массив.

**Чем больше** значение для класса, тем выше приоритет. В данном примере преоритет в порядке `a3->a1->a2`.

>>>>>>> 564f849e2c519ba42f3fd8c629b09a2771052053
